使用 setwd输入具体路径，例如：
# setwd('D:/R4Psy/data/penguin/')
# or 
# setwd('D:\\R4Psy\\data\\penguin')
半自动档 另外，还有Brucer这个包，它提供了一个半自动的方式。你可以在Brucer的WD函数中加上一个参数argument，值为ask = T，它会弹出一个交互窗口，让你选择你希望哪个文件夹作为你的工作目录。
# 两个函数等价，ask = T设置弹出交互式窗口选择文件夹
bruceR::set.wd(ask = T)
bruceR::set_wd(ask = T)

# 读取数据,命名为penguin_data
penguin_data = import(here::here("Book",'data', 'penguin', 'penguin_rawdata.csv'))
# 查看头(head) 5 行，有头就有尾(tail)
# head(penguin_data,n = 3)
# tail(penguin_data,n = 3)

#getwd 返回当前工作目录，返回的数据类型是？
class(getwd())

# 选取前 2 行以及前 3 列数据
penguin_data[1:2,1:3]

# 选取前 2 行以：：
penguin_data[1:2,c('age','ALEX1','ALEX2')]
c('age','ALEX1','ALEX2') == cc('age,ALEX1,ALEX2')

## 根据列名进行索引
head(penguin_data$age)

4.9.2 缺失值（NA） 空值（NULL）
NA：代表缺失值，任何数值与NA进行计算都会得到NA，因此在计算或绘图中，需要移除缺失值或对其进行填补
unique(penguin_data\$ALEX1)
#直接计算会得到 NA
mean(penguin_data$ALEX1)
# 因此计算时需要移除 NA(remove)：
mean(penguin_data$ALEX1,na.rm = T)
NULL表示空值，没有任何数据或内容，比如penguin_data$ALEX1 = NULL。会直接删除 ALEX1 这一列（注意：该操作不可逆）
R 语言中有一类函数以 as.开头，如as.numeric()、as.data.frame()，会对数据类型进行转换，比如：

x = TRUE
x = as.numeric(x)
class(x)
x = as.character(x)
class(x)
类似地，也存在一类函数以is.开头，判断对象是否属于某一类型，返回逻辑值：

is.character(x)

今天我们正式开始用r来处理数据。记得去年教授这门课程时，有同学遇到了报错和乱码的问题，无法正常显示，这是因为部分语言设置不正确。为避免此类问题，大家可以将自己的编程语言设置为英文，这样就不会出现乱码了。也就是说，当你遇到报错时，如果系统默认语言是中文，那么在输出时可能会有乱码，无法被识别，这是一个小问题。将界面语言设置成英文的代码如下：


# set local encoding to English
if (.Platform$OS.type == 'windows') {
  Sys.setlocale(category = 'LC_ALL','English_United States.1250')
} else {
  Sys.setlocale(category = 'LC_ALL','en_US.UTF-8')
}
# set the feedback language to English
Sys.setenv(LANG = "en") 

比如你需要对一个数据进行筛选，然后再进行排序。一般来说，传统的思路是先有一个中间变量，对数据进行筛选后，将其保存为中间变量，然后再对这个保存的变量进行排序，排序完成后，再保存为另一个新的变量。这样的话，实际上中间就产生了多个中间变量。这样就会占用我们的内存。

假设需找到data中age大于30的所有行，并排序，代码如下:

filtered_data <- filter(data,age>30)
filtered_sorted_data <- arrange(filtered_data,age)
如果我们使用管道操作的话，它就是直接以这个data作为输入，经过filter之后，然后再经过arrange排序之后，它会返回到这个filtered_sorted_data。这样的话，我们就省掉了一些中间的步骤。如果你的中间步骤非常长的话，那你省掉的中间变量就非常多。这样的话，你的代码就不会占用过多的内存，也会很整洁。

使用管道操作符后，代码变为：

filtered_sorted_data <- data %>%
filter(age >30) %>%
arrange(age)

med_model <- "''
  # 直接效应(Y = cX)
  CBT ~ c*DEQ   # 语法同回归，但需要声明回归系数
  
  # 中介路径(M)
  CSI ~ a*DEQ
  CBT ~ b*CSI
  
  # 定义间接效应c'
  #注： `:=`意思是根据已有的参数定义新的参数
  ab := a*b

  # 总效应
  total := c + (a*b)"
# 注：这里数据仅以处于浪漫关系中的个体为例
fit <- lavaan::sem(med_model,
           data = pg_raw %>% dplyr::filter(romantic == 1),
           bootstrap = 100 # 建议1000
           )